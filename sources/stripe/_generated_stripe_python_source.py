# ==============================================================================
# Merged Lakeflow Source: stripe
# ==============================================================================
# This file is auto-generated by scripts/merge_python_source.py
# Do not edit manually. Make changes to the source files instead.
# ==============================================================================

from datetime import datetime
from decimal import Decimal
from typing import (
    Any,
    Dict,
    Iterator,
    List,
    Tuple,
)
import json
import time

from pyspark.sql import Row
from pyspark.sql.datasource import DataSource, DataSourceReader, SimpleDataSourceStreamReader
from pyspark.sql.types import *
import requests


def register_lakeflow_source(spark):
    """Register the Lakeflow Python source with Spark."""

    ########################################################
    # libs/utils.py
    ########################################################

    def parse_value(value: Any, field_type: DataType) -> Any:
        """
        Converts a JSON value into a PySpark-compatible data type based on the provided field type.
        """
        if value is None:
            return None
        # Handle complex types
        if isinstance(field_type, StructType):
            # Validate input for StructType
            if not isinstance(value, dict):
                raise ValueError(f"Expected a dictionary for StructType, got {type(value)}")
            # Spark Python -> Arrow conversion require missing StructType fields to be assigned None.
            if value == {}:
                raise ValueError(
                    f"field in StructType cannot be an empty dict. Please assign None as the default value instead."
                )
            # For StructType, recursively parse fields into a Row
            field_dict = {}
            for field in field_type.fields:
                # When a field does not exist in the input:
                # 1. set it to None when schema marks it as nullable
                # 2. Otherwise, raise an error.
                if field.name in value:
                    field_dict[field.name] = parse_value(
                        value.get(field.name), field.dataType
                    )
                elif field.nullable:
                    field_dict[field.name] = None
                else:
                    raise ValueError(
                        f"Field {field.name} is not nullable but not found in the input"
                    )

            return Row(**field_dict)
        elif isinstance(field_type, ArrayType):
            # For ArrayType, parse each element in the array
            if not isinstance(value, list):
                # Handle edge case: single value that should be an array
                if field_type.containsNull:
                    # Try to convert to a single-element array if nulls are allowed
                    return [parse_value(value, field_type.elementType)]
                else:
                    raise ValueError(f"Expected a list for ArrayType, got {type(value)}")
            return [parse_value(v, field_type.elementType) for v in value]
        elif isinstance(field_type, MapType):
            # Handle MapType - new support
            if not isinstance(value, dict):
                raise ValueError(f"Expected a dictionary for MapType, got {type(value)}")
            return {
                parse_value(k, field_type.keyType): parse_value(v, field_type.valueType)
                for k, v in value.items()
            }
        # Handle primitive types with more robust error handling and type conversion
        try:
            if isinstance(field_type, StringType):
                # Don't convert None to "None" string
                return str(value) if value is not None else None
            elif isinstance(field_type, (IntegerType, LongType)):
                # Convert numeric strings and floats to integers
                if isinstance(value, str) and value.strip():
                    # Handle numeric strings
                    if "." in value:
                        return int(float(value))
                    return int(value)
                elif isinstance(value, (int, float)):
                    return int(value)
                raise ValueError(f"Cannot convert {value} to integer")
            elif isinstance(field_type, FloatType) or isinstance(field_type, DoubleType):
                # New support for floating point types
                if isinstance(value, str) and value.strip():
                    return float(value)
                return float(value)
            elif isinstance(field_type, DecimalType):
                # New support for Decimal type

                if isinstance(value, str) and value.strip():
                    return Decimal(value)
                return Decimal(str(value))
            elif isinstance(field_type, BooleanType):
                # Enhanced boolean conversion
                if isinstance(value, str):
                    lowered = value.lower()
                    if lowered in ("true", "t", "yes", "y", "1"):
                        return True
                    elif lowered in ("false", "f", "no", "n", "0"):
                        return False
                return bool(value)
            elif isinstance(field_type, DateType):
                # New support for DateType
                if isinstance(value, str):
                    # Try multiple date formats
                    for fmt in ("%Y-%m-%d", "%m/%d/%Y", "%d-%m-%Y", "%Y/%m/%d"):
                        try:
                            return datetime.strptime(value, fmt).date()
                        except ValueError:
                            continue
                    # ISO format as fallback
                    return datetime.fromisoformat(value).date()
                elif isinstance(value, datetime):
                    return value.date()
                raise ValueError(f"Cannot convert {value} to date")
            elif isinstance(field_type, TimestampType):
                # Enhanced timestamp handling
                if isinstance(value, str):
                    # Handle multiple timestamp formats including Z and timezone offsets
                    if value.endswith("Z"):
                        value = value.replace("Z", "+00:00")
                    try:
                        return datetime.fromisoformat(value)
                    except ValueError:
                        # Try additional formats if ISO format fails
                        for fmt in ("%Y-%m-%d %H:%M:%S", "%Y/%m/%d %H:%M:%S"):
                            try:
                                return datetime.strptime(value, fmt)
                            except ValueError:
                                continue
                elif isinstance(value, (int, float)):
                    # Handle Unix timestamps
                    return datetime.fromtimestamp(value)
                elif isinstance(value, datetime):
                    return value
                raise ValueError(f"Cannot convert {value} to timestamp")
            else:
                # Check for custom UDT handling
                if hasattr(field_type, "fromJson"):
                    # Support for User Defined Types that implement fromJson
                    return field_type.fromJson(value)
                raise TypeError(f"Unsupported field type: {field_type}")
        except (ValueError, TypeError) as e:
            # Add context to the error
            raise ValueError(
                f"Error converting '{value}' ({type(value)}) to {field_type}: {str(e)}"
            )


    ########################################################
    # sources/stripe/stripe.py
    ########################################################

    class LakeflowConnect:
        def __init__(self, options: dict) -> None:
            """
            Initialize the Stripe connector with API credentials.

            Args:
                options: Dictionary containing:
                    - api_key: Stripe secret API key (sk_test_* or sk_live_*)
            """
            self.api_key = options["api_key"]
            self.base_url = "https://api.stripe.com/v1"
            self.auth = (self.api_key, "")  # API key as username, empty password

            # Cache for schemas to avoid repeated computation
            self._schema_cache = {}

            # Centralized object metadata configuration
            self._object_config = {
                "customers": {
                    "primary_key": "id",
                    "cursor_field": "created",
                    "ingestion_type": "cdc",
                    "endpoint": "customers",
                    "supports_deleted": True,
                },
                "charges": {
                    "primary_key": "id",
                    "cursor_field": "created",
                    "ingestion_type": "cdc",
                    "endpoint": "charges",
                    "supports_deleted": False,
                },
                "payment_intents": {
                    "primary_key": "id",
                    "cursor_field": "created",
                    "ingestion_type": "cdc",
                    "endpoint": "payment_intents",
                    "supports_deleted": False,
                },
                "subscriptions": {
                    "primary_key": "id",
                    "cursor_field": "created",
                    "ingestion_type": "cdc",
                    "endpoint": "subscriptions",
                    "supports_deleted": False,
                },
                "invoices": {
                    "primary_key": "id",
                    "cursor_field": "created",
                    "ingestion_type": "cdc",
                    "endpoint": "invoices",
                    "supports_deleted": False,
                },
                "products": {
                    "primary_key": "id",
                    "cursor_field": "created",
                    "ingestion_type": "cdc",
                    "endpoint": "products",
                    "supports_deleted": True,
                },
                "prices": {
                    "primary_key": "id",
                    "cursor_field": "created",
                    "ingestion_type": "cdc",
                    "endpoint": "prices",
                    "supports_deleted": False,
                },
                "refunds": {
                    "primary_key": "id",
                    "cursor_field": "created",
                    "ingestion_type": "cdc",
                    "endpoint": "refunds",
                    "supports_deleted": False,
                },
                "disputes": {
                    "primary_key": "id",
                    "cursor_field": "created",
                    "ingestion_type": "cdc",
                    "endpoint": "disputes",
                    "supports_deleted": False,
                },
                "payment_methods": {
                    "primary_key": "id",
                    "cursor_field": "created",
                    "ingestion_type": "cdc",
                    "endpoint": "payment_methods",
                    "supports_deleted": False,
                },
                "balance_transactions": {
                    "primary_key": "id",
                    "cursor_field": "created",
                    "ingestion_type": "cdc",
                    "endpoint": "balance_transactions",
                    "supports_deleted": False,
                },
                "payouts": {
                    "primary_key": "id",
                    "cursor_field": "created",
                    "ingestion_type": "cdc",
                    "endpoint": "payouts",
                    "supports_deleted": False,
                },
                "invoice_items": {
                    "primary_key": "id",
                    "cursor_field": "created",
                    "ingestion_type": "cdc",
                    "endpoint": "invoiceitems",
                    "supports_deleted": False,
                },
                "plans": {
                    "primary_key": "id",
                    "cursor_field": "created",
                    "ingestion_type": "cdc",
                    "endpoint": "plans",
                    "supports_deleted": True,
                },
                "events": {
                    "primary_key": "id",
                    "cursor_field": "created",
                    "ingestion_type": "cdc",
                    "endpoint": "events",
                    "supports_deleted": False,
                },
                "coupons": {
                    "primary_key": "id",
                    "cursor_field": "created",
                    "ingestion_type": "cdc",
                    "endpoint": "coupons",
                    "supports_deleted": False,
                },
            }

            # Reusable nested schema for Stripe address objects
            self._address_schema = StructType(
                [
                    StructField("line1", StringType(), True),
                    StructField("line2", StringType(), True),
                    StructField("city", StringType(), True),
                    StructField("state", StringType(), True),
                    StructField("postal_code", StringType(), True),
                    StructField("country", StringType(), True),
                ]
            )

            # Reusable nested schema for shipping (includes address + name/phone)
            self._shipping_schema = StructType(
                [
                    StructField("name", StringType(), True),
                    StructField("phone", StringType(), True),
                    StructField("address", self._address_schema, True),
                ]
            )

            # Reusable nested schema for billing details
            self._billing_details_schema = StructType(
                [
                    StructField("address", self._address_schema, True),
                    StructField("email", StringType(), True),
                    StructField("name", StringType(), True),
                    StructField("phone", StringType(), True),
                    StructField("tax_id", StringType(), True),
                ]
            )

            # Nested schema for card checks
            self._card_checks_schema = StructType(
                [
                    StructField("address_line1_check", StringType(), True),
                    StructField("address_postal_code_check", StringType(), True),
                    StructField("cvc_check", StringType(), True),
                ]
            )

            # Nested schema for card details in payment_method_details
            self._card_details_schema = StructType(
                [
                    StructField("amount_authorized", LongType(), True),
                    StructField("authorization_code", StringType(), True),
                    StructField("brand", StringType(), True),
                    StructField("checks", self._card_checks_schema, True),
                    StructField("country", StringType(), True),
                    StructField("exp_month", LongType(), True),
                    StructField("exp_year", LongType(), True),
                    StructField("fingerprint", StringType(), True),
                    StructField("funding", StringType(), True),
                    StructField("last4", StringType(), True),
                    StructField("network", StringType(), True),
                    StructField("network_transaction_id", StringType(), True),
                    StructField("regulated_status", StringType(), True),
                    StructField("installments", StringType(), True),
                    StructField("mandate", StringType(), True),
                    StructField("three_d_secure", StringType(), True),
                    StructField("wallet", StringType(), True),
                    StructField("extended_authorization", StringType(), True),
                    StructField("incremental_authorization", StringType(), True),
                    StructField("multicapture", StringType(), True),
                    StructField("network_token", StringType(), True),
                    StructField("overcapture", StringType(), True),
                ]
            )

            # Nested schema for payment_method_details (polymorphic - card is most common)
            self._payment_method_details_schema = StructType(
                [
                    StructField("type", StringType(), True),
                    StructField("card", self._card_details_schema, True),
                    # Other payment types stored as JSON strings for flexibility
                    StructField("ach_credit_transfer", StringType(), True),
                    StructField("ach_debit", StringType(), True),
                    StructField("acss_debit", StringType(), True),
                    StructField("affirm", StringType(), True),
                    StructField("afterpay_clearpay", StringType(), True),
                    StructField("alipay", StringType(), True),
                    StructField("amazon_pay", StringType(), True),
                    StructField("au_becs_debit", StringType(), True),
                    StructField("bacs_debit", StringType(), True),
                    StructField("bancontact", StringType(), True),
                    StructField("blik", StringType(), True),
                    StructField("boleto", StringType(), True),
                    StructField("card_present", StringType(), True),
                    StructField("cashapp", StringType(), True),
                    StructField("customer_balance", StringType(), True),
                    StructField("eps", StringType(), True),
                    StructField("fpx", StringType(), True),
                    StructField("giropay", StringType(), True),
                    StructField("grabpay", StringType(), True),
                    StructField("ideal", StringType(), True),
                    StructField("interac_present", StringType(), True),
                    StructField("klarna", StringType(), True),
                    StructField("konbini", StringType(), True),
                    StructField("link", StringType(), True),
                    StructField("multibanco", StringType(), True),
                    StructField("oxxo", StringType(), True),
                    StructField("p24", StringType(), True),
                    StructField("paynow", StringType(), True),
                    StructField("paypal", StringType(), True),
                    StructField("pix", StringType(), True),
                    StructField("promptpay", StringType(), True),
                    StructField("revolut_pay", StringType(), True),
                    StructField("sepa_debit", StringType(), True),
                    StructField("sofort", StringType(), True),
                    StructField("stripe_account", StringType(), True),
                    StructField("swish", StringType(), True),
                    StructField("us_bank_account", StringType(), True),
                    StructField("wechat", StringType(), True),
                    StructField("wechat_pay", StringType(), True),
                    StructField("zip", StringType(), True),
                ]
            )

            # Nested schema for charge outcome
            self._outcome_schema = StructType(
                [
                    StructField("type", StringType(), True),
                    StructField("network_status", StringType(), True),
                    StructField("reason", StringType(), True),
                    StructField("risk_level", StringType(), True),
                    StructField("risk_score", LongType(), True),
                    StructField("seller_message", StringType(), True),
                    StructField("advice_code", StringType(), True),
                    StructField("network_advice_code", StringType(), True),
                    StructField("network_decline_code", StringType(), True),
                ]
            )

            # Nested schema for price recurring
            self._recurring_schema = StructType(
                [
                    StructField("interval", StringType(), True),
                    StructField("interval_count", LongType(), True),
                    StructField("meter", StringType(), True),
                    StructField("trial_period_days", LongType(), True),
                    StructField("usage_type", StringType(), True),
                    StructField("aggregate_usage", StringType(), True),
                ]
            )

            # Nested schema for fee detail (used in balance_transactions.fee_details array)
            self._fee_detail_schema = StructType(
                [
                    StructField("amount", LongType(), True),
                    StructField("application", StringType(), True),
                    StructField("currency", StringType(), True),
                    StructField("description", StringType(), True),
                    StructField("type", StringType(), True),
                ]
            )

            # Nested schema for period (used in invoice line items, subscriptions, etc.)
            self._period_schema = StructType(
                [
                    StructField("start", LongType(), True),
                    StructField("end", LongType(), True),
                ]
            )

            # Nested schema for invoice line item
            self._invoice_line_item_schema = StructType(
                [
                    StructField("id", StringType(), True),
                    StructField("object", StringType(), True),
                    StructField("amount", LongType(), True),
                    StructField("amount_excluding_tax", LongType(), True),
                    StructField("currency", StringType(), True),
                    StructField("description", StringType(), True),
                    StructField("discountable", BooleanType(), True),
                    StructField("discounts", StringType(), True),
                    StructField("discount_amounts", StringType(), True),
                    StructField("invoice", StringType(), True),
                    StructField("invoice_item", StringType(), True),
                    StructField("livemode", BooleanType(), True),
                    StructField("metadata", StringType(), True),
                    StructField("period", self._period_schema, True),
                    StructField("plan", StringType(), True),
                    StructField("price", StringType(), True),
                    StructField("proration", BooleanType(), True),
                    StructField("proration_details", StringType(), True),
                    StructField("quantity", LongType(), True),
                    StructField("subscription", StringType(), True),
                    StructField("subscription_item", StringType(), True),
                    StructField("tax_amounts", StringType(), True),
                    StructField("tax_rates", StringType(), True),
                    StructField("type", StringType(), True),
                    StructField("unit_amount_excluding_tax", StringType(), True),
                ]
            )

            # Nested schema for invoice lines (paginated list wrapper)
            self._invoice_lines_schema = StructType(
                [
                    StructField("object", StringType(), True),
                    StructField("data", ArrayType(self._invoice_line_item_schema), True),
                    StructField("has_more", BooleanType(), True),
                    StructField("total_count", LongType(), True),
                    StructField("url", StringType(), True),
                ]
            )

            # Nested schema for invoice payment settings
            self._invoice_payment_settings_schema = StructType(
                [
                    StructField("default_mandate", StringType(), True),
                    StructField("payment_method_options", StringType(), True),
                    StructField("payment_method_types", StringType(), True),
                ]
            )

            # Nested schema for invoice status transitions
            self._status_transitions_schema = StructType(
                [
                    StructField("finalized_at", LongType(), True),
                    StructField("marked_uncollectible_at", LongType(), True),
                    StructField("paid_at", LongType(), True),
                    StructField("voided_at", LongType(), True),
                ]
            )

            # Nested schema for card payment method options
            self._card_payment_method_options_schema = StructType(
                [
                    StructField("installments", StringType(), True),
                    StructField("mandate_options", StringType(), True),
                    StructField("network", StringType(), True),
                    StructField("request_three_d_secure", StringType(), True),
                    StructField("setup_future_usage", StringType(), True),
                    StructField("capture_method", StringType(), True),
                ]
            )

            # Nested schema for payment_method_options (polymorphic)
            self._payment_method_options_schema = StructType(
                [
                    StructField("card", self._card_payment_method_options_schema, True),
                    StructField("acss_debit", StringType(), True),
                    StructField("affirm", StringType(), True),
                    StructField("afterpay_clearpay", StringType(), True),
                    StructField("alipay", StringType(), True),
                    StructField("amazon_pay", StringType(), True),
                    StructField("au_becs_debit", StringType(), True),
                    StructField("bacs_debit", StringType(), True),
                    StructField("bancontact", StringType(), True),
                    StructField("blik", StringType(), True),
                    StructField("boleto", StringType(), True),
                    StructField("cashapp", StringType(), True),
                    StructField("customer_balance", StringType(), True),
                    StructField("eps", StringType(), True),
                    StructField("fpx", StringType(), True),
                    StructField("giropay", StringType(), True),
                    StructField("grabpay", StringType(), True),
                    StructField("ideal", StringType(), True),
                    StructField("interac_present", StringType(), True),
                    StructField("klarna", StringType(), True),
                    StructField("konbini", StringType(), True),
                    StructField("link", StringType(), True),
                    StructField("mobilepay", StringType(), True),
                    StructField("multibanco", StringType(), True),
                    StructField("oxxo", StringType(), True),
                    StructField("p24", StringType(), True),
                    StructField("paynow", StringType(), True),
                    StructField("paypal", StringType(), True),
                    StructField("pix", StringType(), True),
                    StructField("promptpay", StringType(), True),
                    StructField("revolut_pay", StringType(), True),
                    StructField("sepa_debit", StringType(), True),
                    StructField("sofort", StringType(), True),
                    StructField("swish", StringType(), True),
                    StructField("us_bank_account", StringType(), True),
                    StructField("wechat_pay", StringType(), True),
                    StructField("zip", StringType(), True),
                ]
            )

            # Centralized schema configuration
            self._schema_config = {
                "customers": StructType(
                    [
                        StructField("id", StringType(), False),
                        StructField("object", StringType(), True),
                        StructField("created", LongType(), True),
                        StructField("livemode", BooleanType(), True),
                        StructField("email", StringType(), True),
                        StructField("name", StringType(), True),
                        StructField("phone", StringType(), True),
                        StructField("description", StringType(), True),
                        StructField("address", self._address_schema, True),
                        StructField("shipping", self._shipping_schema, True),
                        StructField("balance", LongType(), True),
                        StructField("currency", StringType(), True),
                        StructField("delinquent", BooleanType(), True),
                        StructField("preferred_locales", ArrayType(StringType()), True),
                        StructField("invoice_settings", StringType(), True),
                        StructField("tax_exempt", StringType(), True),
                        StructField("default_source", StringType(), True),
                        StructField("invoice_prefix", StringType(), True),
                        StructField("metadata", StringType(), True),
                        StructField("discount", StringType(), True),
                        StructField("deleted", BooleanType(), True),
                        StructField("test_clock", StringType(), True),
                        StructField("tax", StringType(), True),
                        StructField("sources", StringType(), True),
                        StructField("subscriptions", StringType(), True),
                        StructField("next_invoice_sequence", LongType(), True),
                    ]
                ),
                "charges": StructType(
                    [
                        StructField("id", StringType(), False),
                        StructField("object", StringType(), True),
                        StructField("created", LongType(), True),
                        StructField("livemode", BooleanType(), True),
                        StructField("amount", LongType(), True),
                        StructField("amount_captured", LongType(), True),
                        StructField("amount_refunded", LongType(), True),
                        StructField("currency", StringType(), True),
                        StructField("status", StringType(), True),
                        StructField("paid", BooleanType(), True),
                        StructField("refunded", BooleanType(), True),
                        StructField("captured", BooleanType(), True),
                        StructField("disputed", BooleanType(), True),
                        StructField("customer", StringType(), True),
                        StructField("invoice", StringType(), True),
                        StructField("payment_intent", StringType(), True),
                        StructField("payment_method", StringType(), True),
                        StructField("description", StringType(), True),
                        StructField("receipt_email", StringType(), True),
                        StructField("receipt_url", StringType(), True),
                        StructField("statement_descriptor", StringType(), True),
                        StructField("billing_details", self._billing_details_schema, True),
                        StructField("payment_method_details", self._payment_method_details_schema, True),
                        StructField("outcome", self._outcome_schema, True),
                        StructField("metadata", StringType(), True),
                        StructField("failure_code", StringType(), True),
                        StructField("failure_message", StringType(), True),
                    ]
                ),
                "payment_intents": StructType(
                    [
                        StructField("id", StringType(), False),
                        StructField("object", StringType(), True),
                        StructField("created", LongType(), True),
                        StructField("livemode", BooleanType(), True),
                        StructField("amount", LongType(), True),
                        StructField("amount_capturable", LongType(), True),
                        StructField("amount_received", LongType(), True),
                        StructField("currency", StringType(), True),
                        StructField("status", StringType(), True),
                        StructField("canceled_at", LongType(), True),
                        StructField("cancellation_reason", StringType(), True),
                        StructField("customer", StringType(), True),
                        StructField("invoice", StringType(), True),
                        StructField("payment_method", StringType(), True),
                        StructField("description", StringType(), True),
                        StructField("receipt_email", StringType(), True),
                        StructField("statement_descriptor", StringType(), True),
                        StructField("capture_method", StringType(), True),
                        StructField("confirmation_method", StringType(), True),
                        StructField("charges", StringType(), True),
                        StructField("payment_method_options", self._payment_method_options_schema, True),
                        StructField("shipping", StringType(), True),
                        StructField("metadata", StringType(), True),
                        StructField("latest_charge", StringType(), True),
                    ]
                ),
                "subscriptions": StructType(
                    [
                        StructField("id", StringType(), False),
                        StructField("object", StringType(), True),
                        StructField("created", LongType(), True),
                        StructField("livemode", BooleanType(), True),
                        StructField("status", StringType(), True),
                        StructField("current_period_start", LongType(), True),
                        StructField("current_period_end", LongType(), True),
                        StructField("cancel_at", LongType(), True),
                        StructField("canceled_at", LongType(), True),
                        StructField("ended_at", LongType(), True),
                        StructField("trial_start", LongType(), True),
                        StructField("trial_end", LongType(), True),
                        StructField("customer", StringType(), True),
                        StructField("default_payment_method", StringType(), True),
                        StructField("latest_invoice", StringType(), True),
                        StructField("billing_cycle_anchor", LongType(), True),
                        StructField("collection_method", StringType(), True),
                        StructField("days_until_due", LongType(), True),
                        StructField("items", StringType(), True),
                        StructField("metadata", StringType(), True),
                        StructField("discount", StringType(), True),
                        StructField("cancel_at_period_end", BooleanType(), True),
                    ]
                ),
                "invoices": StructType(
                    [
                        # Core identifiers
                        StructField("id", StringType(), False),
                        StructField("object", StringType(), True),
                        StructField("created", LongType(), True),
                        StructField("livemode", BooleanType(), True),
                        # Status and payment info
                        StructField("status", StringType(), True),
                        StructField("paid", BooleanType(), True),
                        StructField("paid_out_of_band", BooleanType(), True),
                        StructField("attempted", BooleanType(), True),
                        StructField("attempt_count", LongType(), True),
                        StructField("auto_advance", BooleanType(), True),
                        # Amounts
                        StructField("amount_due", LongType(), True),
                        StructField("amount_paid", LongType(), True),
                        StructField("amount_remaining", LongType(), True),
                        StructField("amount_shipping", LongType(), True),
                        StructField("total", LongType(), True),
                        StructField("subtotal", LongType(), True),
                        StructField("subtotal_excluding_tax", LongType(), True),
                        StructField("total_excluding_tax", LongType(), True),
                        StructField("tax", LongType(), True),
                        StructField("starting_balance", LongType(), True),
                        StructField("ending_balance", LongType(), True),
                        StructField("pre_payment_credit_notes_amount", LongType(), True),
                        StructField("post_payment_credit_notes_amount", LongType(), True),
                        StructField("currency", StringType(), True),
                        # Customer info
                        StructField("customer", StringType(), True),
                        StructField("customer_email", StringType(), True),
                        StructField("customer_name", StringType(), True),
                        StructField("customer_phone", StringType(), True),
                        StructField("customer_address", self._address_schema, True),
                        StructField("customer_shipping", self._shipping_schema, True),
                        StructField("customer_tax_exempt", StringType(), True),
                        StructField("customer_tax_ids", StringType(), True),
                        # References
                        StructField("subscription", StringType(), True),
                        StructField("charge", StringType(), True),
                        StructField("payment_intent", StringType(), True),
                        StructField("default_payment_method", StringType(), True),
                        StructField("default_source", StringType(), True),
                        StructField("quote", StringType(), True),
                        StructField("latest_revision", StringType(), True),
                        StructField("from_invoice", StringType(), True),
                        # Billing details
                        StructField("billing_reason", StringType(), True),
                        StructField("collection_method", StringType(), True),
                        StructField("description", StringType(), True),
                        StructField("footer", StringType(), True),
                        StructField("statement_descriptor", StringType(), True),
                        StructField("receipt_number", StringType(), True),
                        # Dates
                        StructField("due_date", LongType(), True),
                        StructField("period_start", LongType(), True),
                        StructField("period_end", LongType(), True),
                        StructField("next_payment_attempt", LongType(), True),
                        StructField("webhooks_delivered_at", LongType(), True),
                        StructField("effective_at", LongType(), True),
                        # URLs
                        StructField("number", StringType(), True),
                        StructField("hosted_invoice_url", StringType(), True),
                        StructField("invoice_pdf", StringType(), True),
                        # Account info
                        StructField("account_country", StringType(), True),
                        StructField("account_name", StringType(), True),
                        StructField("account_tax_ids", StringType(), True),
                        # Connect
                        StructField("application", StringType(), True),
                        StructField("application_fee_amount", LongType(), True),
                        StructField("on_behalf_of", StringType(), True),
                        StructField("transfer_data", StringType(), True),
                        # Complex nested objects
                        StructField("automatic_tax", StringType(), True),
                        StructField("custom_fields", StringType(), True),
                        StructField("default_tax_rates", StringType(), True),
                        StructField("discount", StringType(), True),
                        StructField("discounts", StringType(), True),
                        StructField("issuer", StringType(), True),
                        StructField("last_finalization_error", StringType(), True),
                        StructField("lines", self._invoice_lines_schema, True),
                        StructField("payment_settings", self._invoice_payment_settings_schema, True),
                        StructField("rendering", StringType(), True),
                        StructField("shipping_cost", StringType(), True),
                        StructField("shipping_details", StringType(), True),
                        StructField("status_transitions", self._status_transitions_schema, True),
                        StructField("subscription_details", StringType(), True),
                        StructField("threshold_reason", StringType(), True),
                        StructField("total_discount_amounts", StringType(), True),
                        StructField("total_tax_amounts", StringType(), True),
                        StructField("metadata", StringType(), True),
                        StructField("test_clock", StringType(), True),
                    ]
                ),
                "products": StructType(
                    [
                        StructField("id", StringType(), False),
                        StructField("object", StringType(), True),
                        StructField("created", LongType(), True),
                        StructField("updated", LongType(), True),
                        StructField("livemode", BooleanType(), True),
                        StructField("name", StringType(), True),
                        StructField("description", StringType(), True),
                        StructField("active", BooleanType(), True),
                        StructField("type", StringType(), True),
                        StructField("unit_label", StringType(), True),
                        StructField("url", StringType(), True),
                        StructField("images", ArrayType(StringType()), True),
                        StructField("metadata", StringType(), True),
                        StructField("statement_descriptor", StringType(), True),
                        StructField("tax_code", StringType(), True),
                        StructField("shippable", BooleanType(), True),
                        StructField("deleted", BooleanType(), True),
                        StructField("default_price", StringType(), True),
                        StructField("features", StringType(), True),
                        StructField("package_dimensions", StringType(), True),
                    ]
                ),
                "prices": StructType(
                    [
                        StructField("id", StringType(), False),
                        StructField("object", StringType(), True),
                        StructField("created", LongType(), True),
                        StructField("livemode", BooleanType(), True),
                        StructField("active", BooleanType(), True),
                        StructField("currency", StringType(), True),
                        StructField("unit_amount", LongType(), True),
                        StructField("unit_amount_decimal", StringType(), True),
                        StructField("product", StringType(), True),
                        StructField("billing_scheme", StringType(), True),
                        StructField("type", StringType(), True),
                        StructField("recurring", self._recurring_schema, True),
                        StructField("lookup_key", StringType(), True),
                        StructField("nickname", StringType(), True),
                        StructField("tax_behavior", StringType(), True),
                        StructField("tiers", StringType(), True),
                        StructField("tiers_mode", StringType(), True),
                        StructField("metadata", StringType(), True),
                    ]
                ),
                "refunds": StructType(
                    [
                        StructField("id", StringType(), False),
                        StructField("object", StringType(), True),
                        StructField("created", LongType(), True),
                        StructField("livemode", BooleanType(), True),
                        StructField("amount", LongType(), True),
                        StructField("currency", StringType(), True),
                        StructField("charge", StringType(), True),
                        StructField("payment_intent", StringType(), True),
                        StructField("status", StringType(), True),
                        StructField("reason", StringType(), True),
                        StructField("receipt_number", StringType(), True),
                        StructField("metadata", StringType(), True),
                        StructField("failure_reason", StringType(), True),
                    ]
                ),
                "disputes": StructType(
                    [
                        StructField("id", StringType(), False),
                        StructField("object", StringType(), True),
                        StructField("created", LongType(), True),
                        StructField("livemode", BooleanType(), True),
                        StructField("amount", LongType(), True),
                        StructField("currency", StringType(), True),
                        StructField("charge", StringType(), True),
                        StructField("payment_intent", StringType(), True),
                        StructField("status", StringType(), True),
                        StructField("reason", StringType(), True),
                        StructField("evidence", StringType(), True),
                        StructField("evidence_details", StringType(), True),
                        StructField("is_charge_refundable", BooleanType(), True),
                        StructField("metadata", StringType(), True),
                    ]
                ),
                "payment_methods": StructType(
                    [
                        StructField("id", StringType(), False),
                        StructField("object", StringType(), True),
                        StructField("created", LongType(), True),
                        StructField("livemode", BooleanType(), True),
                        StructField("type", StringType(), True),
                        StructField("customer", StringType(), True),
                        StructField("billing_details", self._billing_details_schema, True),
                        StructField("card", StringType(), True),
                        StructField("us_bank_account", StringType(), True),
                        StructField("metadata", StringType(), True),
                    ]
                ),
                "balance_transactions": StructType(
                    [
                        StructField("id", StringType(), False),
                        StructField("object", StringType(), True),
                        StructField("created", LongType(), True),
                        StructField("livemode", BooleanType(), True),
                        StructField("amount", LongType(), True),
                        StructField("currency", StringType(), True),
                        StructField("net", LongType(), True),
                        StructField("fee", LongType(), True),
                        StructField("fee_details", ArrayType(self._fee_detail_schema), True),
                        StructField("type", StringType(), True),
                        StructField("source", StringType(), True),
                        StructField("status", StringType(), True),
                        StructField("description", StringType(), True),
                        StructField("available_on", LongType(), True),
                        StructField("exchange_rate", DoubleType(), True),
                        StructField("reporting_category", StringType(), True),
                    ]
                ),
                "payouts": StructType(
                    [
                        StructField("id", StringType(), False),
                        StructField("object", StringType(), True),
                        StructField("created", LongType(), True),
                        StructField("livemode", BooleanType(), True),
                        StructField("amount", LongType(), True),
                        StructField("currency", StringType(), True),
                        StructField("arrival_date", LongType(), True),
                        StructField("status", StringType(), True),
                        StructField("type", StringType(), True),
                        StructField("method", StringType(), True),
                        StructField("destination", StringType(), True),
                        StructField("description", StringType(), True),
                        StructField("balance_transaction", StringType(), True),
                        StructField("failure_code", StringType(), True),
                        StructField("failure_message", StringType(), True),
                        StructField("metadata", StringType(), True),
                    ]
                ),
                "invoice_items": StructType(
                    [
                        StructField("id", StringType(), False),
                        StructField("object", StringType(), True),
                        StructField("created", LongType(), True),
                        StructField("livemode", BooleanType(), True),
                        StructField("amount", LongType(), True),
                        StructField("currency", StringType(), True),
                        StructField("customer", StringType(), True),
                        StructField("invoice", StringType(), True),
                        StructField("subscription", StringType(), True),
                        StructField("price", StringType(), True),
                        StructField("description", StringType(), True),
                        StructField("quantity", LongType(), True),
                        StructField("unit_amount", LongType(), True),
                        StructField("unit_amount_decimal", StringType(), True),
                        StructField("period", StringType(), True),
                        StructField("discounts", StringType(), True),
                        StructField("metadata", StringType(), True),
                        StructField("proration", BooleanType(), True),
                        StructField("date", LongType(), True),
                        StructField("discountable", BooleanType(), True),
                        StructField("tax_rates", StringType(), True),
                    ]
                ),
                "plans": StructType(
                    [
                        StructField("id", StringType(), False),
                        StructField("object", StringType(), True),
                        StructField("created", LongType(), True),
                        StructField("livemode", BooleanType(), True),
                        StructField("active", BooleanType(), True),
                        StructField("amount", LongType(), True),
                        StructField("currency", StringType(), True),
                        StructField("interval", StringType(), True),
                        StructField("interval_count", LongType(), True),
                        StructField("product", StringType(), True),
                        StructField("nickname", StringType(), True),
                        StructField("usage_type", StringType(), True),
                        StructField("aggregate_usage", StringType(), True),
                        StructField("trial_period_days", LongType(), True),
                        StructField("tiers", StringType(), True),
                        StructField("tiers_mode", StringType(), True),
                        StructField("metadata", StringType(), True),
                        StructField("deleted", BooleanType(), True),
                    ]
                ),
                "events": StructType(
                    [
                        StructField("id", StringType(), False),
                        StructField("object", StringType(), True),
                        StructField("created", LongType(), True),
                        StructField("livemode", BooleanType(), True),
                        StructField("type", StringType(), True),
                        StructField("data", StringType(), True),
                        StructField("api_version", StringType(), True),
                        StructField("request", StringType(), True),
                        StructField("pending_webhooks", LongType(), True),
                    ]
                ),
                "coupons": StructType(
                    [
                        StructField("id", StringType(), False),
                        StructField("object", StringType(), True),
                        StructField("created", LongType(), True),
                        StructField("livemode", BooleanType(), True),
                        StructField("name", StringType(), True),
                        StructField("amount_off", LongType(), True),
                        StructField("percent_off", DoubleType(), True),
                        StructField("currency", StringType(), True),
                        StructField("duration", StringType(), True),
                        StructField("duration_in_months", LongType(), True),
                        StructField("max_redemptions", LongType(), True),
                        StructField("times_redeemed", LongType(), True),
                        StructField("redeem_by", LongType(), True),
                        StructField("valid", BooleanType(), True),
                        StructField("applies_to", StringType(), True),
                        StructField("metadata", StringType(), True),
                        StructField("currency_options", StringType(), True),
                    ]
                ),
            }

        def list_tables(self) -> list[str]:
            """
            List available Stripe tables/objects.

            Returns:
                List of supported table names
            """
            return [
                "customers",
                "charges",
                "payment_intents",
                "subscriptions",
                "invoices",
                "products",
                "prices",
                "refunds",
                "disputes",
                "payment_methods",
                "balance_transactions",
                "payouts",
                "invoice_items",
                "plans",
                "events",
                "coupons",
            ]

        def get_table_schema(
            self, table_name: str, table_options: Dict[str, str]
        ) -> StructType:
            """
            Get the Spark schema for a Stripe table.

            Args:
                table_name: Name of the table

            Returns:
                StructType representing the table schema
            """
            schema = self._schema_config[table_name]
            return schema

        def read_table_metadata(
            self, table_name: str, table_options: Dict[str, str]
        ) -> dict:
            """
            Get metadata for a Stripe table.

            Args:
                table_name: Name of the table

            Returns:
                Dictionary with primary_key, cursor_field, and ingestion_type
            """
            config = self._object_config[table_name]
            return {
                "primary_key": config["primary_key"],
                "cursor_field": config["cursor_field"],
                "ingestion_type": config["ingestion_type"],
            }

        def read_table(
            self, table_name: str, start_offset: dict, table_options: Dict[str, str]
        ) -> Tuple[List[Dict], Dict]:
            """
            Read data from a Stripe table.

            Args:
                table_name: Name of the table to read
                start_offset: Dictionary containing cursor information for incremental reads
                    - For incremental: {"created": <unix_timestamp>}
                    - For full refresh: None or {}

            Returns:
                Tuple of (records, new_offset)
            """
            if table_name not in self._object_config:
                raise ValueError(f"Unsupported table: {table_name}")

            config = self._object_config[table_name]

            # Determine if this is an incremental read
            is_incremental = (
                start_offset is not None
                and start_offset.get(config["cursor_field"]) is not None
            )

            if is_incremental:
                return self._read_data_incremental(table_name, start_offset)
            else:
                return self._read_data_full(table_name)

        def _read_data_full(self, table_name: str) -> Tuple[List[Dict], Dict]:
            """
            Read all data from a Stripe table (full refresh).

            Args:
                table_name: Name of the table

            Returns:
                Tuple of (all_records, offset)
            """
            config = self._object_config[table_name]
            endpoint = config["endpoint"]
            cursor_field = config["cursor_field"]

            all_records = []
            starting_after = None
            latest_cursor_value = 0

            while True:
                # Build request parameters
                params = {
                    "limit": 100  # Max allowed by Stripe
                }

                if starting_after:
                    params["starting_after"] = starting_after

                # Make API request
                url = f"{self.base_url}/{endpoint}"
                response = requests.get(url, auth=self.auth, params=params)

                if response.status_code != 200:
                    raise Exception(
                        f"Stripe API error for {table_name}: {response.status_code} {response.text}"
                    )

                data = response.json()
                records = data.get("data", [])

                if not records:
                    break

                all_records.extend(records)

                # Track the latest cursor value for checkpointing
                for record in records:
                    cursor_value = record.get(cursor_field, 0)
                    if cursor_value > latest_cursor_value:
                        latest_cursor_value = cursor_value

                # Check if there are more pages
                has_more = data.get("has_more", False)
                if not has_more:
                    break

                # Get the last object ID for pagination
                starting_after = records[-1]["id"]

                # Rate limiting - be nice to the API
                time.sleep(0.1)

            # Return records and offset for next incremental sync
            offset = {cursor_field: latest_cursor_value} if latest_cursor_value > 0 else {}
            return all_records, offset

        def _read_data_incremental(
            self, table_name: str, start_offset: dict
        ) -> Tuple[List[Dict], Dict]:
            """
            Read incremental data from a Stripe table using cursor.

            Args:
                table_name: Name of the table
                start_offset: Dictionary with cursor field value

            Returns:
                Tuple of (new_records, new_offset)
            """
            config = self._object_config[table_name]
            endpoint = config["endpoint"]
            cursor_field = config["cursor_field"]

            # Get the starting point from offset
            cursor_start = start_offset.get(cursor_field, 0)

            all_records = []
            starting_after = None
            latest_cursor_value = cursor_start

            while True:
                # Build request parameters for incremental fetch
                params = {
                    "limit": 100,
                    f"{cursor_field}[gte]": cursor_start,  # Greater than or equal to last cursor
                }

                if starting_after:
                    params["starting_after"] = starting_after

                # Make API request
                url = f"{self.base_url}/{endpoint}"
                response = requests.get(url, auth=self.auth, params=params)

                if response.status_code != 200:
                    raise Exception(
                        f"Stripe API error for {table_name}: {response.status_code} {response.text}"
                    )

                data = response.json()
                records = data.get("data", [])

                if not records:
                    break

                all_records.extend(records)

                # Track the latest cursor value
                for record in records:
                    cursor_value = record.get(cursor_field, 0)
                    if cursor_value > latest_cursor_value:
                        latest_cursor_value = cursor_value

                # Check if there are more pages
                has_more = data.get("has_more", False)
                if not has_more:
                    break

                # Get the last object ID for pagination
                starting_after = records[-1]["id"]

                # Rate limiting
                time.sleep(0.1)

            # Return new offset for next sync
            offset = {cursor_field: latest_cursor_value}
            return all_records, offset

        def test_connection(self) -> dict:
            """
            Test the connection to Stripe API.

            Returns:
                Dictionary with status and message
            """
            try:
                url = f"{self.base_url}/customers?limit=1"
                response = requests.get(url, auth=self.auth)

                if response.status_code == 200:
                    return {"status": "success", "message": "Connection successful"}
                else:
                    return {
                        "status": "error",
                        "message": f"API error: {response.status_code} {response.text}",
                    }
            except Exception as e:
                return {"status": "error", "message": f"Connection failed: {str(e)}"}


    ########################################################
    # pipeline/lakeflow_python_source.py
    ########################################################

    METADATA_TABLE = "_lakeflow_metadata"
    TABLE_NAME = "tableName"
    TABLE_NAME_LIST = "tableNameList"


    class LakeflowStreamReader(SimpleDataSourceStreamReader):
        """
        Implements a data source stream reader for Lakeflow Connect.
        Currently, only the simpleStreamReader is implemented, which uses a
        more generic protocol suitable for most data sources that support
        incremental loading.
        """

        def __init__(
            self,
            options: dict[str, str],
            schema: StructType,
            lakeflow_connect: LakeflowConnect,
        ):
            self.options = options
            self.lakeflow_connect = lakeflow_connect
            self.schema = schema

        def initialOffset(self):
            return {}

        def read(self, start: dict) -> (Iterator[tuple], dict):
            records, offset = self.lakeflow_connect.read_table(
                self.options["tableName"], start, self.options
            )
            rows = map(lambda x: parse_value(x, self.schema), records)
            return rows, offset

        def readBetweenOffsets(self, start: dict, end: dict) -> Iterator[tuple]:
            # TODO: This does not ensure the records returned are identical across repeated calls.
            # For append-only tables, the data source must guarantee that reading from the same
            # start offset will always yield the same set of records.
            # For tables ingested as incremental CDC, it is only necessary that no new changes
            # are missed in the returned records.
            return self.read(start)[0]


    class LakeflowBatchReader(DataSourceReader):
        def __init__(
            self,
            options: dict[str, str],
            schema: StructType,
            lakeflow_connect: LakeflowConnect,
        ):
            self.options = options
            self.schema = schema
            self.lakeflow_connect = lakeflow_connect
            self.table_name = options[TABLE_NAME]

        def read(self, partition):
            all_records = []
            if self.table_name == METADATA_TABLE:
                all_records = self._read_table_metadata()
            else:
                all_records, _ = self.lakeflow_connect.read_table(
                    self.table_name, None, self.options
                )

            rows = map(lambda x: parse_value(x, self.schema), all_records)
            return iter(rows)

        def _read_table_metadata(self):
            table_name_list = self.options.get(TABLE_NAME_LIST, "")
            table_names = [o.strip() for o in table_name_list.split(",") if o.strip()]
            all_records = []
            for table in table_names:
                metadata = self.lakeflow_connect.read_table_metadata(table, self.options)
                all_records.append({"tableName": table, **metadata})
            return all_records


    class LakeflowSource(DataSource):
        def __init__(self, options):
            self.options = options
            self.lakeflow_connect = LakeflowConnect(options)

        @classmethod
        def name(cls):
            return "lakeflow_connect"

        def schema(self):
            table = self.options["tableName"]
            if table == METADATA_TABLE:
                return StructType(
                    [
                        StructField("tableName", StringType(), False),
                        StructField("primary_key", ArrayType(StringType()), True),
                        StructField("cursor_field", StringType(), True),
                        StructField("ingestion_type", StringType(), True),
                    ]
                )
            else:
                # Assuming the LakeflowConnect interface uses get_table_schema, not get_table_details
                return self.lakeflow_connect.get_table_schema(table, self.options)

        def reader(self, schema: StructType):
            return LakeflowBatchReader(self.options, schema, self.lakeflow_connect)

        def simpleStreamReader(self, schema: StructType):
            return LakeflowStreamReader(self.options, schema, self.lakeflow_connect)


    spark.dataSource.register(LakeflowSource)
